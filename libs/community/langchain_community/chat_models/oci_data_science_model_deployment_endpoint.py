from langchain_core.outputs import ChatGeneration, ChatGenerationChunk, ChatResult
from langchain_core.pydantic_v1 import Field, root_validator
from langchain_core.utils import get_from_dict_or_env
from langchain_core.callbacks import (
    AsyncCallbackManagerForLLMRun,
    CallbackManagerForLLMRun,
)
from langchain_core.language_models import LanguageModelInput
from langchain_core.messages import BaseMessage, AIMessageChunk
from langchain_community.adapters.openai import (
    convert_dict_to_message,
    convert_message_to_dict,
)
from langchain_core.tools import BaseTool
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Iterator,
    AsyncIterator,
    Union,
    Sequence,
    Callable,
    Type,
    Literal,
)
from langchain_core.runnables import Runnable
from langchain_core.pydantic_v1 import BaseModel
from langchain_community.chat_models.openai import _convert_delta_to_message_chunk
import requests
from langchain_core.language_models.llms import create_base_retry_decorator
import json
from langchain_community.utilities.requests import Requests
import aiohttp
from langchain_core.language_models.chat_models import (
    BaseChatModel,
    agenerate_from_stream,
    generate_from_stream,
)
from langchain_core.utils.function_calling import (
    convert_to_openai_tool,
)

DEFAULT_TIME_OUT = 300
DEFAULT_CONTENT_TYPE_JSON = "application/json"
DEFAULT_MODEL_NAME = "odsc-llm"


class TokenExpiredError(Exception):
    pass


def _create_retry_decorator(
    llm,
    *,
    max_retries: int = 1,
    run_manager: Optional[
        Union[AsyncCallbackManagerForLLMRun, CallbackManagerForLLMRun]
    ] = None,
) -> Callable[[Any], Any]:
    """Create a retry decorator."""
    errors = [requests.exceptions.ConnectTimeout, TokenExpiredError]
    decorator = create_base_retry_decorator(
        error_types=errors, max_retries=max_retries, run_manager=run_manager
    )
    return decorator


class ChatOCIModelDeploymentEndpoint(BaseChatModel):
    """OCI large language chat models.

    To authenticate, the OCI client uses the methods described in
    https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdk_authentication_methods.htm

    The authentifcation method is passed through auth_type and should be one of:
    API_KEY (default), SECURITY_TOKEN, INSTANCE_PRINCIPAL, RESOURCE_PRINCIPAL

    Make sure you have the required policies (profile/roles) to
    access the OCI Generative AI service.
    If a specific config profile is used, you must pass
    the name of the profile (from ~/.oci/config) through auth_profile.

    To use, you must provide the compartment id
    along with the endpoint url, and model id
    as named parameters to the constructor.

    Example:
        .. code-block:: python

            from langchain_community.chat_models import ChatOCIModelDeploymentEndpoint

            llm = ChatOCIModelDeploymentEndpoint(
                )
    """

    """Base class for LLM deployed on OCI Data Science Model Deployment."""

    auth: dict = Field(default_factory=dict, exclude=True)
    """ADS auth dictionary for OCI authentication:
    https://accelerated-data-science.readthedocs.io/en/latest/user_guide/cli/authentication.html.
    This can be generated by calling `ads.common.auth.api_keys()`
    or `ads.common.auth.resource_principal()`. If this is not
    provided then the `ads.common.default_signer()` will be used."""

    endpoint: str = ""
    """The uri of the endpoint from the deployed Model Deployment model."""

    streaming: bool = False
    """Whether to stream the results or not."""

    model_kwargs: Dict[str, Any] = Field(default_factory=dict)
    """Keyword arguments to pass to the model."""

    model: str = DEFAULT_MODEL_NAME
    """The name of the model."""

    # TODO: discuss if needed
    max_tokens: int = 256
    """Denotes the number of tokens to predict per generation."""

    temperature: float = 0.2
    """A non-negative float that tunes the degree of randomness in generation."""

    k: int = -1
    """Number of most likely tokens to consider at each step."""

    p: float = 0.75
    """Total probability mass of tokens to consider at each step."""

    best_of: int = 1
    """Generates best_of completions server-side and returns the "best"
    (the one with the highest log probability per token).
    """

    stop: Optional[List[str]] = None
    """Stop words to use when generating. Model output is cut off
    at the first occurrence of any of these substrings."""

    @root_validator()
    def validate_environment(  # pylint: disable=no-self-argument
        cls, values: Dict
    ) -> Dict:
        """Validate that python package exists in environment."""
        try:
            import ads

        except ImportError as ex:
            raise ImportError(
                "Could not import ads python package. "
                "Please install it with `pip install oracle_ads`."
            ) from ex
        if not values.get("auth", None):
            values["auth"] = ads.common.auth.default_signer()
        values["endpoint"] = get_from_dict_or_env(
            values,
            "endpoint",
            "OCI_LLM_ENDPOINT",
        )
        return values

    @property
    def _llm_type(self) -> str:
        """Return type of llm."""
        return "oci_model_depolyment_chat_endpoint"

    @classmethod
    def is_lc_serializable(cls) -> bool:
        """Return whether this model can be serialized by Langchain."""
        return True

    @classmethod
    def get_lc_namespace(cls) -> List[str]:
        """Get the namespace of the langchain object."""
        return [
            "langchain",
            "chat_models",
            "oci_data_science_model_deployment_endpoint",
        ]

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        """Get the identifying parameters."""
        _model_kwargs = self.model_kwargs or {}
        return {
            **{"model_kwargs": _model_kwargs},
        }

    @property
    def _default_params(self) -> Dict[str, Any]:
        """Get the default parameters."""
        # TODO: default parameter should be required one? or the most freq used one?
        return {
            "model": self.model,
            # "max_tokens": self.max_tokens,
            "stop": self.stop,
            "temperature": self.temperature,
            "top_k": self.k,
            "top_p": self.p,
            "stream": self.streaming,
            # "whole_output_stream": self.streaming,
            **self.model_kwargs,  # will overwrite value
        }

    def _invocation_params(self, stop: Optional[List[str]], **kwargs: Any) -> dict:
        """Combines the invocation parameters with default parameters."""
        params = self._default_params
        # stop pased to _generate has higher priority
        params["stop"] = stop or params["stop"]
        return {**params, **kwargs}

    def _construct_json_body(self, messages: list, params: dict) -> dict:
        """Constructs the request body as a dictionary (JSON)."""
        # TODO: add tools related params
        return {
            "messages": [convert_message_to_dict(m) for m in messages],
            **params,
        }

    def _process_stream_response(
        self, response_json: dict, default_chunk_cls=AIMessageChunk
    ) -> ChatGenerationChunk:
        """Formats response for OpenAI spec.
        {"id":"cmpl-350e41c3d94a4b66b3d27f494e893069",
        "object":"chat.completion.chunk",
        "created":99245,
        "model":"odsc-llm",
        "choices":[{
            "index":0,
            "delta":{"role":"assistant"},
            "finish_reason":null}]}

        """
        try:
            choice = response_json["choices"][0]
            if not isinstance(choice, dict):
                raise TypeError("Endpoint response is not well formed.")
        except (KeyError, IndexError, TypeError) as e:
            raise ValueError(
                "Error while formatting response payload for chat model of type"
            ) from e

        chunk = _convert_delta_to_message_chunk(choice["delta"], default_chunk_cls)
        default_chunk_cls = chunk.__class__
        finish_reason = choice.get("finish_reason")
        usage = choice.get("usage")
        gen_info = {}
        if finish_reason is not None:
            gen_info.update({"finish_reason": finish_reason})
        if usage is not None:
            gen_info.update({"usage": usage})

        return ChatGenerationChunk(
            message=chunk, generation_info=gen_info if gen_info else None
        )

    def _process_response(self, response_json: dict) -> ChatResult:
        """Formats response for OpenAI spec.

        sample response:
        {'id': 'cmpl-c115536d6d284a0ebbd49bf7107cd778',
        'object': 'chat.completion',
        'created': 96512,
        'model': 'odsc-llm',
        'choices': [{'index': 0,
        'message': {'role': 'assistant',
            'content': "?\nDeep learning is a subset of machine learning, which is based on artificial neural networks. It is designed to simulate the behavior of the human brain â€“ to learn from large amounts of data and improve its performance as it is exposed to more data.\n\nIn deep learning, artificial neural networks are employed to make predictions or decisions without being explicitly programmed to perform the task. These neural networks are made up of many layers of interconnected nodes or neurons, which can be trained to recognize patterns in the data.\n\nThe main difference between deep learning and traditional machine learning is the depth of the neural network. In deep learning, there are many layers of interconnected nodes, while in traditional machine learning there are usually just one or two layers. This depth allows deep learning models to better understand the input data and make more accurate predictions.\n\nHere's a simple example of how deep learning can be used:\n\n- A deep learning algorithm can be trained on a large dataset of images of cats and dogs. The goal is to build a model that can look at any image and determine whether it is a cat or a dog.\n- The deep learning algorithm would use many layers of interconnected nodes to analyze different features of the images, such as the shapes of the eyes, the size of the ears, and the patterns in the fur.\n- As the algorithm is exposed to more images, it can refine its understanding of what constitutes a cat and what constitutes a dog, improving its accuracy over time.\n\nDeep learning has been applied to a wide range of fields, including image and speech recognition, natural language processing, and even playing games like Go and chess."},
        'finish_reason': 'stop'}],
        'usage': {'prompt_tokens': 34, 'total_tokens': 383, 'completion_tokens': 349}}

        """
        generations = []
        try:
            choices = response_json["choices"]
            if not isinstance(choices, list):
                raise TypeError("Endpoint response is not well formed.")
        except (KeyError, TypeError) as e:
            raise ValueError(
                "Error while formatting response payload for chat model of type"
            ) from e

        for choice in choices:
            message = convert_dict_to_message(choice["message"])
            generation_info = dict(finish_reason=choice.get("finish_reason"))
            if "logprobs" in choice:
                generation_info["logprobs"] = choice["logprobs"]

            gen = ChatGeneration(
                message=message,
                generation_info=generation_info,
            )
            generations.append(gen)

        token_usage = response_json.get("usage", {})
        llm_output = {
            "token_usage": token_usage,
            "model_name": self.model,
            "system_fingerprint": response_json.get("system_fingerprint", ""),
        }
        return ChatResult(generations=generations, llm_output=llm_output)

    def _headers(self, is_async=False, body=None) -> Dict:
        if is_async:
            signer = self.auth["signer"]
            req = requests.Request("POST", self.endpoint, json=body)
            req = req.prepare()
            req = signer(req)
            headers = {}
            for key, value in req.headers.items():
                headers[key] = value

            if self.streaming:
                headers.update(
                    {"enable-streaming": "true", "Accept": "text/event-stream"}
                )
            return headers

        return (
            {
                "Content-Type": DEFAULT_CONTENT_TYPE_JSON,
                "enable-streaming": "true",
                "Accept": "text/event-stream",
            }
            if self.streaming
            else {
                "Content-Type": DEFAULT_CONTENT_TYPE_JSON,
            }
        )

    def completion_with_retry(
        self, run_manager: Optional[CallbackManagerForLLMRun] = None, **kwargs: Any
    ) -> Any:
        """Use tenacity to retry the completion call."""
        retry_decorator = _create_retry_decorator(self, run_manager=run_manager)

        @retry_decorator
        def _completion_with_retry(**kwargs: Any) -> Any:
            try:
                request_timeout = kwargs.pop("request_timeout", DEFAULT_TIME_OUT)
                data = kwargs.pop("data")
                stream = kwargs.pop("stream", self.streaming)

                request = Requests(
                    headers=self._headers(), auth=self.auth.get("signer")
                )
                print(data)
                response = request.post(
                    url=self.endpoint,
                    data=data,
                    timeout=request_timeout,
                    stream=stream,
                    **kwargs,
                )
                response.raise_for_status()
                return response
            except requests.exceptions.HTTPError as http_err:
                if response.status_code == 401 and self._refresh_signer():
                    raise TokenExpiredError() from http_err
                else:
                    raise ValueError(
                        f"Error occurs by inference endpoint "
                        f"{str(http_err)}: {response.text}"
                    ) from http_err
            except Exception as err:
                raise ValueError(
                    f"Error occurs by inference endpoint: {str(err)}"
                ) from err

        return _completion_with_retry(**kwargs)

    async def acompletion_with_retry(
        self,
        run_manager: Optional[AsyncCallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> Any:
        """Use tenacity to retry the async completion call."""
        retry_decorator = _create_retry_decorator(self, run_manager=run_manager)

        @retry_decorator
        async def _completion_with_retry(**kwargs: Any) -> Any:
            try:
                request_timeout = kwargs.pop("request_timeout", DEFAULT_TIME_OUT)
                data = kwargs.pop("data")
                stream = kwargs.pop("stream", self.streaming)

                request = Requests(headers=self._headers(is_async=True, body=data))
                if stream:
                    response = request.apost(
                        url=self.endpoint,
                        data=data,
                        timeout=request_timeout,
                    )
                    return self._aiter_sse(response)
                else:
                    async with request.apost(
                        url=self.endpoint,
                        data=data,
                        timeout=request_timeout,
                    ) as resp:
                        resp.raise_for_status()
                        data = await resp.json()
                        return data
            except Exception as err:
                raise ValueError(
                    f"Error occurs by inference endpoint " f"{str(err)}"
                ) from err

        return await _completion_with_retry(**kwargs)

    def _generate(
        self,
        messages: List[BaseMessage],
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        stream: Optional[bool] = None,
        **kwargs: Any,
    ) -> ChatResult:
        """Call out to an OCI Model Deployment Online endpoint.

        Args:
            messages:  The messages in the conversation with the chat model.
            stop: Optional list of stop words to use when generating.
            run_manager:
            stream: Optional

        Returns:
            LangChain ChatResult

        Raises:
            ValueError:
                Raise when invoking endpoint fails.

        Example:

            .. code-block:: python

                from langchain_core.messages import HumanMessage, AIMessage

                messages = [
                            HumanMessage(content="hello!"),
                            AIMessage(content="Hi there human!"),
                            HumanMessage(content="Meow!")
                          ]
                response = chat.invoke(messages)
        """
        should_stream = stream if stream is not None else self.streaming
        if should_stream:
            stream_iter = self._stream(
                messages, stop=stop, run_manager=run_manager, **kwargs
            )
            return generate_from_stream(stream_iter)

        params = self._invocation_params(stop, **kwargs)
        body = self._construct_json_body(messages, params)
        res = self.completion_with_retry(
            data=body,
            run_manager=run_manager,
            # **kwargs,
        )
        return self._process_response(res.json())

    def _stream(
        self,
        messages: List[BaseMessage],
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> Iterator[ChatGenerationChunk]:
        """Stream OCI Data Science Model Deployment endpoint on given messages.

        Args:
            messages (List[BaseMessage]):
                The messagaes to pass into the model.
            stop (List[str], Optional):
                List of stop words to use when generating.
            kwargs:
                requests_kwargs:
                    Additional ``**kwargs`` to pass to requests.post

        Returns:
            An iterator of ChatGenerationChunk.

        Raises:
            ValueError:
                Raise when invoking endpoint fails.

        Example:

            .. code-block:: python

                messages = [
                    (
                        "system",
                        "You are a helpful assistant that translates English to French. Translate the user sentence.",
                    ),
                    ("human", "I love programming."),
                ]

                chunk_iter = chat.stream(messages)

        """
        requests_kwargs = kwargs.pop("requests_kwargs", {})
        self.streaming = True
        params = self._invocation_params(stop, **kwargs)
        body = self._construct_json_body(messages, params)  # request json body

        response = self.completion_with_retry(
            data=body, run_manager=run_manager, stream=True, **requests_kwargs
        )
        default_chunk_class = AIMessageChunk
        for line in self._parse_stream(response.iter_lines()):
            # print(default_chunk_class) # check if changing
            chunk = self._handle_sse_line(line, default_chunk_class)
            if run_manager:
                run_manager.on_llm_new_token(chunk.text, chunk=chunk)
            yield chunk

    async def _agenerate(
        self,
        messages: List[BaseMessage],
        stop: Optional[List[str]] = None,
        run_manager: Optional[AsyncCallbackManagerForLLMRun] = None,
        stream: Optional[bool] = None,
        **kwargs: Any,
    ) -> ChatResult:
        should_stream = stream if stream is not None else self.streaming
        if should_stream:
            stream_iter = self._astream(
                messages, stop=stop, run_manager=run_manager, **kwargs
            )
            return await agenerate_from_stream(stream_iter)

        params = self._invocation_params(stop, **kwargs)
        body = self._construct_json_body(messages, params)
        response = await self.acompletion_with_retry(
            data=body,
            run_manager=run_manager,
            **kwargs,
        )
        return self._process_response(response)

    async def _astream(
        self,
        messages: List[BaseMessage],
        stop: Optional[List[str]] = None,
        run_manager: Optional[AsyncCallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> AsyncIterator[ChatGenerationChunk]:
        requests_kwargs = kwargs.pop("requests_kwargs", {})
        self.streaming = True
        params = self._invocation_params(stop, **kwargs)
        body = self._construct_json_body(messages, params)  # request json body

        default_chunk_class = AIMessageChunk
        async for line in await self.acompletion_with_retry(
            data=body, run_manager=run_manager, stream=True, **requests_kwargs
        ):
            chunk = self._handle_sse_line(line, default_chunk_class)
            if run_manager:
                run_manager.on_llm_new_token(chunk.text, chunk=chunk)
            yield chunk

    def bind_tools(
        self,
        tools: Sequence[Union[Dict[str, Any], Type[BaseModel], Callable, BaseTool]],
        *,
        tool_choice: Optional[
            Union[dict, str, Literal["auto", "none", "required", "any"], bool]
        ] = None,
        **kwargs: Any,
    ) -> Runnable[LanguageModelInput, BaseMessage]:
        """Bind tool-like objects to this chat model.

        Assumes model is compatible with OpenAI tool-calling API.

        Args:
            tools: A list of tool definitions to bind to this chat model.
                Can be  a dictionary, pydantic model, callable, or BaseTool. Pydantic
                models, callables, and BaseTools will be automatically converted to
                their schema dictionary representation.
            tool_choice: Which tool to require the model to call.
                Options are:
                name of the tool (str): calls corresponding tool;
                "auto": automatically selects a tool (including no tool);
                "none": does not call a tool;
                "any" or "required": force at least one tool to be called;
                True: forces tool call (requires `tools` be length 1);
                False: no effect;

                or a dict of the form:
                {"type": "function", "function": {"name": <<tool_name>>}}.
            **kwargs: Any additional parameters to pass to the
                :class:`~langchain.runnable.Runnable` constructor.
        """
        pass
        # formatted_tools = [convert_to_openai_tool(tool) for tool in tools]
        # if tool_choice:
        #     if isinstance(tool_choice, str):
        #         # tool_choice is a tool/function name
        #         if tool_choice not in ("auto", "none", "any", "required"):
        #             tool_choice = {
        #                 "type": "function",
        #                 "function": {"name": tool_choice},
        #             }
        #         # 'any' is not natively supported by OpenAI API.
        #         # We support 'any' since other models use this instead of 'required'.
        #         if tool_choice == "any":
        #             tool_choice = "required"
        #     elif isinstance(tool_choice, bool):
        #         tool_choice = "required"
        #     elif isinstance(tool_choice, dict):
        #         tool_names = [
        #             formatted_tool["function"]["name"]
        #             for formatted_tool in formatted_tools
        #         ]
        #         if not any(
        #             tool_name == tool_choice["function"]["name"]
        #             for tool_name in tool_names
        #         ):
        #             raise ValueError(
        #                 f"Tool choice {tool_choice} was specified, but the only "
        #                 f"provided tools were {tool_names}."
        #             )
        #     else:
        #         raise ValueError(
        #             f"Unrecognized tool_choice type. Expected str, bool or dict. "
        #             f"Received: {tool_choice}"
        #         )
        #     kwargs["tool_choice"] = tool_choice
        # return super().bind(tools=formatted_tools, **kwargs)

    def _parse_stream(self, lines: Iterator[bytes]) -> Iterator[str]:
        for line in lines:
            _line = self._parse_stream_line(line)
            if _line is not None:
                yield _line

    async def _parse_stream_async(
        self,
        lines: aiohttp.StreamReader,
    ) -> AsyncIterator[str]:
        async for line in lines:
            _line = self._parse_stream_line(line)
            if _line is not None:
                yield _line

    def _parse_stream_line(self, line: bytes) -> Optional[str]:
        line = line.strip()
        if line:
            line = line.decode("utf-8")
            if "[DONE]" in line:
                return None

            if line.startswith("data:"):
                return line[6:] if line.startswith("data: ") else line[5:]
        return None

    def _handle_sse_line(
        self, line: str, default_chunk_cls: AIMessageChunk
    ) -> ChatGenerationChunk:
        try:
            obj = json.loads(line)
            return self._process_stream_response(obj, default_chunk_cls)
        except Exception:
            return ChatGenerationChunk()

    async def _aiter_sse(
        self,
        async_cntx_mgr,
    ) -> AsyncIterator[Dict]:
        """Iterate over the server-sent events."""
        async with async_cntx_mgr as client_resp:
            client_resp.raise_for_status()
            async for line in self._parse_stream_async(client_resp.content):
                yield line

    def _refresh_signer(self) -> None:
        """Refresh token."""
        if self.auth.get("signer", None) and hasattr(
            self.auth["signer"], "refresh_security_token"
        ):
            self.auth["signer"].refresh_security_token()
            return True
        return False
