---
title: "How to: Splitting HTML"
---

import React from 'react';
import { useColorMode } from '@docusaurus/theme-common';
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";


# How to: Splitting HTML

---

## Overview of HTML Splitting

In Retrieval-Augmented Generation (RAG) workflows, effectively splitting HTML content is crucial for optimizing document retrieval and ensuring that generated responses are contextually accurate. HTML documents often contain a mix of structured and unstructured data, making it challenging to extract meaningful information if not properly split.

Effective HTML splitting can:

- **Preserve Context**: Ensure that elements like `tables`, `lists`, and `headers` remain intact, maintaining relationships and hierarchies within the document.
- **Improve Retrieval Accuracy**: Help match queries to the most relevant parts of the content by maintaining logical flow.
- **Enhance Performance**: Break down documents into manageable, context-rich chunks, leading to faster processing times.

This document will go into each HTML Splitter available in the `langchain_text_splitters` library and provide guidance on when & how to use them effectively.

---

## Types of HTML Splitters

<Tabs>
<TabItem value="section_splitter" label="HTMLSectionSplitter" default>

The `HTMLSectionSplitter` is designed for documents with a clear hierarchical structure defined by HTML headers like `h1`, `h2`, etc. It ensures that related content is grouped together semantically according to the documentâ€™s structure.

#### Key Functionalities:

- **Header-Based Splitting**: Divides documents based on specified HTML headers (e.g., `h1`, `h2`), preserving the natural flow of sections and subsections.
- **Maintains Document Hierarchy**: Ensures that each section of the document remains intact, making it easy to navigate and retrieve specific parts of the content.
- **Customizable Section Handling**: Allows the use of an XSLT file to transform the document, making it possible to detect sections based on custom layouts or non-standard HTML tags.
- **Flexible Section Management**: Works well with nested sections, ensuring that deeply nested content is accurately grouped and preserved within its hierarchical context.

---

:::info Use Cases
- **Structured Documents**: Ideal for academic papers, technical manuals, or any document with a well-defined structure that needs to remain intact during processing.
- **Nested Sections**: Suitable for long documents with multiple levels of headers that need to retain their structure for accurate retrieval and analysis.
- **Custom Layout Handling**: Perfect for documents with non-standard HTML layouts that require custom transformation before processing.
:::

</TabItem>


<TabItem value="header_text_splitter" label="HTMLHeaderTextSplitter">

The `HTMLHeaderTextSplitter` is a straightforward tool for splitting HTML documents based on specific headers. It is ideal for documents where breaking down content by headers like `h1`, `h2`, and `h3` is sufficient, without needing special handling for more complex structures.

#### Key Functionalities:

- **Simple Header-Based Splitting**: Splits content based on HTML headers (e.g., `h1`, `h2`, `h3`), making it a straightforward option for simpler documents.
- **Element-by-Element Control**: Offers the ability to return each HTML element with its associated headers as individual chunks, or aggregate them into larger sections with common metadata.
- **Basic Document Structuring**: Maintains a basic structure of the document, making it easy to extract specific sections or topics based on headers.
- **Flexible Content Aggregation**: Provides flexibility in how content is aggregated, allowing you to group related content or keep it segmented based on your needs.

---

:::info Use Cases
- **Simple Web Pages**: Best for blog posts, articles, or straightforward web pages where splitting by headers like `h1`, `h2`, and `h3` captures the main content effectively.
- **Flat Document Structures**: Suitable for documents that do not contain complex nested elements, making it easy to segment based on headers.
- **Basic Content Extraction**: Ideal for scenarios where basic extraction of content by headers is sufficient without needing advanced handling of more complex HTML elements.
:::

</TabItem>

<TabItem value="semantic_preserving_splitter" label="HTMLSemanticPreservingSplitter">

The `HTMLSemanticPreservingSplitter` is built for complex HTML documents that contain structured elements such as `tables`, `lists`, images, and multimedia content. It excels at preserving the integrity of these elements, ensuring that they are not split across chunks, even if it means creating slightly larger sections.

#### Key Functionalities:

- **Preserves Semantic Structure**: Keeps complex HTML elements like `tables`, `lists`, and media intact, ensuring that they are not split across chunks.
- **Handles Multimedia Content**: Converts `images`, `videos`, and `audio` tags into Markdown-like formats for easy processing while maintaining their contextual relevance.
- **Custom HTML Tag Handling**: Allows you to define custom handlers for any HTML tag. These handlers can extract and format additional information, such as pulling out attributes (e.g., `class`, `id`), specific metadata (e.g., language for `<code>` blocks), or even apply complex transformations to the content.
- **Flexible Chunking**: Allows for flexible chunk sizes to maintain the integrity of content, using recursive splitting only when absolutely necessary.
- **Contextual Continuity**: Supports overlapping chunks to ensure that the flow of information is maintained across sections.

---

:::info Use Cases
- **Data-Rich Documents**: Ideal for documents that include detailed tables, lists, and other data-heavy structures that must remain intact.
- **Multimedia-Rich Content**: Suitable for content with embedded media such as `images`, `videos`, and `audio` where maintaining context and structure is crucial.
- **Custom HTML Tags and Attributes**: Perfect for documents that require specialized handling of HTML tags, such as extracting and storing additional information from `<code>` blocks, `<iframe>` elements, or custom data attributes for further processing.
:::
</TabItem>

</Tabs>

---

## Chunking HTML Example

:::tip Example HTML Page
The below HTML page will serve as an example in the how-to section of this document. We will use each splitter to process this HTML document and demonstrate the output for comparison.

You can find the tabs below on each section, where we will cover the code, the chunks and the different functionalities of each splitter.
:::

{(() => {
  const { colorMode } = useColorMode();

  const bgColor = colorMode === 'dark' ? '#2c2c2c' : '#ffffff';
  const textColor = colorMode === 'dark' ? '#f0f0f0' : '#000000';
  const linkColor = colorMode === 'dark' ? '#1e90ff' : '#1a0dab';
  const borderColor = colorMode === 'dark' ? '#444444' : '#dddddd';
  const thBgColor = colorMode === 'dark' ? '#3b3b3b' : '#f0f0f0';

  const iframeStyle = {
    width: '100%',
    height: '600px',
    border: 'none',
    borderRadius: '12px', // Curved edges
    boxShadow: colorMode === 'dark' 
      ? '0 4px 8px rgba(0, 0, 0, 0.5)' // Darker shadow in dark mode
      : '0 4px 12px rgba(0, 0, 0, 0.1)', // Lighter shadow in light mode
    overflow: 'hidden', // Ensures content stays within rounded corners
    marginTop: '20px', // Adds some space above the iframe
  };

  return (
    <iframe srcDoc={`
      <!DOCTYPE html>
      <html lang='en'>
      <head>
        <meta charset='UTF-8'>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
        <title>Fancy Example HTML Page</title>
        <style>
          body {
            background-color: ${bgColor};
            color: ${textColor};
            font-family: Arial, sans-serif;
          }
          a {
            color: ${linkColor};
          }
          table {
            width: 100%;
            border-collapse: collapse;
          }
          th, td {
            padding: 8px;
            border: 1px solid ${borderColor};
          }
          th {
            background-color: ${thBgColor};
          }
          img, video {
            max-width: 100%;
            height: auto;
          }
        </style>
      </head>
      <body>
        <h1>Main Title</h1>
        <p>This is an introductory paragraph with some basic content.</p>

        <h2>Section 1: Introduction</h2>
        <p>This section introduces the topic. Below is a list:</p>
        <ul>
          <li>First item</li>
          <li>Second item</li>
          <li>Third item with <strong>bold text</strong> and <a href='#'>a link</a></li>
        </ul>

        <h3>Subsection 1.1: Details</h3>
        <p>This subsection provides additional details. Here's a table:</p>
        <table>
          <thead>
            <tr>
              <th>Header 1</th>
              <th>Header 2</th>
              <th>Header 3</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Row 1, Cell 1</td>
              <td>Row 1, Cell 2</td>
              <td>Row 1, Cell 3</td>
            </tr>
            <tr>
              <td>Row 2, Cell 1</td>
              <td>Row 2, Cell 2</td>
              <td>Row 2, Cell 3</td>
            </tr>
          </tbody>
        </table>

        <h2>Section 2: Media Content</h2>
        <p>This section contains an image and a video:</p>
        <img src='example_image_link.mp4' alt='Example Image'>
        <video controls width='250' src='example_video_link.mp4' type='video/mp4'>
          Your browser does not support the video tag.
        </video>

        <h2>Section 3: Code Example</h2>
        <p>This section contains a code block:</p>
        <pre><code data-lang="html">
        &lt;div&gt;
          &lt;p&gt;This is a paragraph inside a div.&lt;/p&gt;
        &lt;/div&gt;
        </code></pre>

        <h2>Conclusion</h2>
        <p>This is the conclusion of the document.</p>
      </body>
      </html>
    `} 
    style={iframeStyle}
    />
  );
})()}

<details>
  <summary>View the raw HTML</summary>

  ```html
  <!DOCTYPE html>
  <html lang='en'>
  <head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Fancy Example HTML Page</title>
  </head>
  <body>
    <h1>Main Title</h1>
    <p>This is an introductory paragraph with some basic content.</p>
    
    <h2>Section 1: Introduction</h2>
    <p>This section introduces the topic. Below is a list:</p>
    <ul>
      <li>First item</li>
      <li>Second item</li>
      <li>Third item with <strong>bold text</strong> and <a href='#'>a link</a></li>
    </ul>
    
    <h3>Subsection 1.1: Details</h3>
    <p>This subsection provides additional details. Here's a table:</p>
    <table border='1'>
      <thead>
        <tr>
          <th>Header 1</th>
          <th>Header 2</th>
          <th>Header 3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Row 1, Cell 1</td>
          <td>Row 1, Cell 2</td>
          <td>Row 1, Cell 3</td>
        </tr>
        <tr>
          <td>Row 2, Cell 1</td>
          <td>Row 2, Cell 2</td>
          <td>Row 2, Cell 3</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Section 2: Media Content</h2>
    <p>This section contains an image and a video:</p>
      <img src='example_image_link.mp4' alt='Example Image'>
      <video controls width='250' src='example_video_link.mp4' type='video/mp4'>
      Your browser does not support the video tag.
    </video>

    <h2>Section 3: Code Example</h2>
    <p>This section contains a code block:</p>
    <pre><code data-lang="html">
    &lt;div&gt;
      &lt;p&gt;This is a paragraph inside a div.&lt;/p&gt;
    &lt;/div&gt;
    </code></pre>

    <h2>Conclusion</h2>
    <p>This is the conclusion of the document.</p>
  </body>
  </html>
```
</details>

---

### Splitting HTML with Different Splitters

<Tabs>
    <TabItem value="header_splitter" label="HTMLHeaderTextSplitter">
    The header splitter is the most simple splitter of the three. It focuses on finding headers provided in `headers_to_split_on` and splitting the document based on them. 
    
    It is the most basic splitter and is ideal for simple documents with a clear structure.

    To utilize this splitter, you can use the following code:

    ```python
    from langchain_text_splitters import HTMLHeaderTextSplitter

    headers_to_split_on = [
        ("h1", "Header 1"),
        ("h2", "Header 2"),
        ("h3", "Header 3"),
    ]

    splitter = HTMLHeaderTextSplitter(
        headers_to_split_on=headers_to_split_on
    )

    chunks = splitter.split_text(html)

    chunks
    ```

    To return each element together with their associated headers, specify `return_each_element=True` when instantiating `HTMLHeaderTextSplitter`:

    ```python
    splitter = HTMLHeaderTextSplitter(
        headers_to_split_on=headers_to_split_on,
        return_each_element=True
    )
    chunks = splitter.split_text(html)

    chunks
    ```

    <details>
        <summary>Document Chunks</summary>

        Chunk 1:
        ```python
        Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some basic content.')
        ```

        Chunk 2:
        ```python
        Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic. Below is a list:  
        First item Second item Third item with bold text and a link')
        ```

        Chunk 3:
        ```python
        Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction', 
        'Header 3': 'Subsection 1.1: Details'}, page_content="This subsection provides additional details. Here's a table:")
        ```

        Chunk 4:
        ```python
        Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video:')
        ```

        Chunk 5:
        ```python
        Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block:')
        ```

        Chunk 6:
        ```python
        Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')
        ```
    </details>


    </TabItem>
    <TabItem value="section_splitter" label="HTMLSectionSplitter">
    The `HTMLSectionSplitter` is a more advanced splitter that focuses on maintaining the hierarchical structure of the document by using HTML headers like `h1`, `h2`, etc. It ensures that sections and subsections are kept intact, making it ideal for documents with complex layouts and nested sections.

    This splitter can also handle custom HTML tags and non-standard document layouts using XSLT transformations.

    To utilize this splitter, you can use the following code:

    ```python
    from langchain_text_splitters import HTMLSectionSplitter

    headers_to_split_on = [
        ("h1", "Header 1"),
        ("h2", "Header 2"),
        ("h3", "Header 3"),
    ]

    splitter = HTMLSectionSplitter(
        headers_to_split_on=headers_to_split_on
    )

    chunks = splitter.split_text(html)

    chunks
    ```

    If your HTML document uses a custom layout or non-standard tags, you can specify an XSLT file for transformation:

    ```python
    splitter = HTMLSectionSplitter(
        headers_to_split_on=headers_to_split_on,
        xslt_path="path/to/your/custom.xslt"
    )

    chunks = splitter.split_text(html)

    chunks
    ```

    <details>
        <summary>Document Chunks</summary>

        Chunk 1:
        ```python
        Document(metadata={'Header 1': 'Main Title'}, page_content='Main Title \n This is an introductory paragraph with some basic content.')
        ```

        Chunk 2:
        ```python
        Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='Section 1: Introduction \n This section introduces the topic. Below is a list: \n \n First item \n Second item \n Third item with  bold text  and  a link')
        ```

        Chunk 3:
        ```python
        Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content="Subsection 1.1: Details \n This subsection provides additional details. Here's a table: \n \n \n \n Header 1 \n Header 2 \n Header 3 \n \n \n \n \n Row 1, Cell 1 \n Row 1, Cell 2 \n Row 1, Cell 3 \n \n \n Row 2, Cell 1 \n Row 2, Cell 2 \n Row 2, Cell 3")
        ```

        Chunk 4:
        ```python
        Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='Section 2: Media Content \n This section contains an image and a video: \n \n \n \n    Your browser does not support the video tag.')
        ```

        Chunk 5:
        ```python
        Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='Section 3: Code Example \n This section contains a code block: \n \n  <div>\n    <p>This is a paragraph inside a div.</p>\n  </div>')
        ```

        Chunk 6:
        ```python
        Document(metadata={'Header 2': 'Conclusion'}, page_content='Conclusion \n This is the conclusion of the document.')
        ```
    </details>
    </TabItem>
    <TabItem value="semantic_preserving_splitter" label="HTMLSemanticPreservingSplitter">

    **The `HTMLSemanticPreservingSplitter`** is designed to handle complex HTML documents with structured elements like tables, lists, images, and multimedia content. It ensures that these elements are preserved within the chunks, maintaining their integrity and context.

    **Notes:**

    - **Preserved Elements:** In this example, we will preserve tables, links, images, videos, and code blocks within the chunks.
    - **Custom Handler:** We will leverage a `custom_handler` to extract and format code blocks with language information from the `data-lang` element within the `<code>` element.
    - **Excluding Elements:** We pass in `<head>` to the `denylist_tags` parameter to exclude the `<head>` HTML section from being processed.
    - You can do the same for `script` tags, `style` tags, etc.

    ```python
    from langchain_text_splitters import HTMLSemanticPreservingSplitter
    headers_to_split_on = [
        ("h1", "Header 1"),
        ("h2", "Header 2"),
        ("h3", "Header 3"),
    ]

    def code_language_handler(element):
        code_lang = element.get("data-lang", "No Language Defined")
        code_block = element.get_text()

        return f"[[{code_lang}: {code_block}]]"

    splitter = HTMLSemanticPreservingSplitter(
        headers_to_split_on=headers_to_split_on,
        elements_to_preserve=["table", "ul", "code"],
        preserve_images=True,
        preserve_videos=True,
        preserve_audio=True,
        custom_handlers={"code": code_language_handler},
        denylist_tags=["head"]
    )

    chunks = splitter.split_text(html)

    ```

    <details>
        <summary>Document Chunks</summary>

        Chunk 1:
        ```python
        Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some basic content.')
        ```

        Chunk 2:
        ```python
        Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic. Below is a list: First item Second item Third item with bold text and a link')
        ```

        Chunk 3:
        ```python
        Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content="This subsection provides additional details. Here's a table: Header 1 Header 2 Header 3 Row 1, Cell 1 Row 1, Cell 2 Row 1, Cell 3 Row 2, Cell 1 Row 2, Cell 2 Row 2, Cell 3")
        ```

        Chunk 4:
        ```python
        Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video: ![image:https://via.placeholder.com/150](https://via.placeholder.com/150) ![video:https://www.w3schools.com/html/mov_bbb.mp4](https://www.w3schools.com/html/mov_bbb.mp4)')
        ```

        Chunk 5:
        ```python
        Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block: [[html: <div> <p>This is a paragraph inside a div.</p> </div> ]]')
        ```

        Chunk 6:
        ```python
        Document(metadata={'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')
        ```
    </details>
    </TabItem>
</Tabs>

---

### Summary of Differences

:::tip Further chunking will impact results
In RAG based workflows, there are times we need to ensure our chunks are a specific size. When using the `HTMLHeaderTextSplitter` and `HTMLSectionSplitter`, you will need to use the `RecursiveCharecterSplitter` to further split the chunks to a specific size.

When using this approach, you will lose the context of the original document as tables, lists and other important elements will be split, and it is recommended to use the `HTMLSemanticPreservingSplitter` for better results.
:::

| Feature/Element         | HTMLHeaderTextSplitter                 | HTMLSectionSplitter                 | HTMLSemanticPreservingSplitter |
|-------------------------|----------------------------------------|-------------------------------------|--------------------------------|
| **Header-Based Split**   | Yes                                    | Yes                                 | Yes                            |
| **List Preservation**    | Yes, if within same header             | Yes, if within same header          | Yes                            |
| **Table Preservation**   | Yes, if within same header             | Yes, if within same header          | Yes                            |
| **Link Preservation**    | No                                     | No                                  | Yes                            |
| **Image Preservation**   | No                                     | No                                  | Yes                            |
| **Video Preservation**   | No                                     | No                                  | Yes                            |
| **Custom HTML Handling** | No                                     | No                                  | Yes                            |

---

## Conclusion

Choosing the right HTML splitter depends on the complexity of your documents and the level of detail you need to preserve. While the `HTMLHeaderTextSplitter` and `HTMLSectionSplitter` are suitable for simpler documents with clear headers, the `HTMLSemanticPreservingSplitter` is the best choice for preserving the semantic structure of complex HTML content.
